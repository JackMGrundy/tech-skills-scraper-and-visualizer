{"ast":null,"code":"'use strict'; // Load modules\n\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\nexports = module.exports = internals.Topo = function () {\n  this._items = [];\n  this.nodes = [];\n};\n\ninternals.Topo.prototype.add = function (nodes, options) {\n  var _this = this;\n\n  options = options || {}; // Validate rules\n\n  var before = [].concat(options.before || []);\n  var after = [].concat(options.after || []);\n  var group = options.group || '?';\n  var sort = options.sort || 0; // Used for merging only\n\n  Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);\n  Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');\n  Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);\n  Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');\n  [].concat(nodes).forEach(function (node, i) {\n    var item = {\n      seq: _this._items.length,\n      sort: sort,\n      before: before,\n      after: after,\n      group: group,\n      node: node\n    };\n\n    _this._items.push(item);\n  }); // Insert event\n\n  var error = this._sort();\n\n  Hoek.assert(!error, 'item', group !== '?' ? 'added into group ' + group : '', 'created a dependencies error');\n  return this.nodes;\n};\n\ninternals.Topo.prototype.merge = function (others) {\n  others = [].concat(others);\n\n  for (var i = 0; i < others.length; ++i) {\n    var other = others[i];\n\n    if (other) {\n      for (var j = 0; j < other._items.length; ++j) {\n        var item = Hoek.shallow(other._items[j]);\n\n        this._items.push(item);\n      }\n    }\n  } // Sort items\n\n\n  this._items.sort(internals.mergeSort);\n\n  for (var _i = 0; _i < this._items.length; ++_i) {\n    this._items[_i].seq = _i;\n  }\n\n  var error = this._sort();\n\n  Hoek.assert(!error, 'merge created a dependencies error');\n  return this.nodes;\n};\n\ninternals.mergeSort = function (a, b) {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};\n\ninternals.Topo.prototype._sort = function () {\n  // Construct graph\n  var graph = {};\n  var graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n  var groups = Object.create(null);\n\n  for (var i = 0; i < this._items.length; ++i) {\n    var item = this._items[i];\n    var seq = item.seq; // Unique across all items\n\n    var group = item.group; // Determine Groups\n\n    groups[group] = groups[group] || [];\n    groups[group].push(seq); // Build intermediary graph using 'before'\n\n    graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n    var after = item.after;\n\n    for (var j = 0; j < after.length; ++j) {\n      graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n    }\n  } // Expand intermediary graph\n\n\n  var graphNodes = Object.keys(graph);\n\n  for (var _i2 = 0; _i2 < graphNodes.length; ++_i2) {\n    var node = graphNodes[_i2];\n    var expandedGroups = [];\n    var graphNodeItems = Object.keys(graph[node]);\n\n    for (var _j = 0; _j < graphNodeItems.length; ++_j) {\n      var _group = graph[node][graphNodeItems[_j]];\n      groups[_group] = groups[_group] || [];\n\n      for (var k = 0; k < groups[_group].length; ++k) {\n        expandedGroups.push(groups[_group][k]);\n      }\n    }\n\n    graph[node] = expandedGroups;\n  } // Merge intermediary graph using graphAfters into final graph\n\n\n  var afterNodes = Object.keys(graphAfters);\n\n  for (var _i3 = 0; _i3 < afterNodes.length; ++_i3) {\n    var _group2 = afterNodes[_i3];\n\n    if (groups[_group2]) {\n      for (var _j2 = 0; _j2 < groups[_group2].length; ++_j2) {\n        var _node = groups[_group2][_j2];\n        graph[_node] = graph[_node].concat(graphAfters[_group2]);\n      }\n    }\n  } // Compile ancestors\n\n\n  var children;\n  var ancestors = {};\n  graphNodes = Object.keys(graph);\n\n  for (var _i4 = 0; _i4 < graphNodes.length; ++_i4) {\n    var _node2 = graphNodes[_i4];\n    children = graph[_node2];\n\n    for (var _j3 = 0; _j3 < children.length; ++_j3) {\n      ancestors[children[_j3]] = (ancestors[children[_j3]] || []).concat(_node2);\n    }\n  } // Topo sort\n\n\n  var visited = {};\n  var sorted = [];\n\n  for (var _i5 = 0; _i5 < this._items.length; ++_i5) {\n    var next = _i5;\n\n    if (ancestors[_i5]) {\n      next = null;\n\n      for (var _j4 = 0; _j4 < this._items.length; ++_j4) {\n        if (visited[_j4] === true) {\n          continue;\n        }\n\n        if (!ancestors[_j4]) {\n          ancestors[_j4] = [];\n        }\n\n        var shouldSeeCount = ancestors[_j4].length;\n        var seenCount = 0;\n\n        for (var _k = 0; _k < shouldSeeCount; ++_k) {\n          if (sorted.indexOf(ancestors[_j4][_k]) >= 0) {\n            ++seenCount;\n          }\n        }\n\n        if (seenCount === shouldSeeCount) {\n          next = _j4;\n          break;\n        }\n      }\n    }\n\n    if (next !== null) {\n      next = next.toString(); // Normalize to string TODO: replace with seq\n\n      visited[next] = true;\n      sorted.push(next);\n    }\n  }\n\n  if (sorted.length !== this._items.length) {\n    return new Error('Invalid dependencies');\n  }\n\n  var seqIndex = {};\n\n  for (var _i6 = 0; _i6 < this._items.length; ++_i6) {\n    var _item = this._items[_i6];\n    seqIndex[_item.seq] = _item;\n  }\n\n  var sortedNodes = [];\n  this._items = sorted.map(function (value) {\n    var sortedItem = seqIndex[value];\n    sortedNodes.push(sortedItem.node);\n    return sortedItem;\n  });\n  this.nodes = sortedNodes;\n};","map":null,"metadata":{},"sourceType":"script"}