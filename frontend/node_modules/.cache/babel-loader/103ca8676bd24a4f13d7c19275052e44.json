{"ast":null,"code":"'use strict'; // Load modules\n\nvar _defineProperty = require(\"/Users/JGrundy/Documents/code/tech-skills-scraper-and-visualizer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/JGrundy/Documents/code/tech-skills-scraper-and-visualizer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/JGrundy/Documents/code/tech-skills-scraper-and-visualizer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/JGrundy/Documents/code/tech-skills-scraper-and-visualizer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"/Users/JGrundy/Documents/code/tech-skills-scraper-and-visualizer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/JGrundy/Documents/code/tech-skills-scraper-and-visualizer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Hoek = require('hoek');\n\nvar Any = require('./types/any');\n\nvar Cast = require('./cast');\n\nvar Errors = require('./errors');\n\nvar Lazy = require('./types/lazy');\n\nvar Ref = require('./ref'); // Declare internals\n\n\nvar internals = {\n  alternatives: require('./types/alternatives'),\n  array: require('./types/array'),\n  boolean: require('./types/boolean'),\n  binary: require('./types/binary'),\n  date: require('./types/date'),\n  func: require('./types/func'),\n  number: require('./types/number'),\n  object: require('./types/object'),\n  string: require('./types/string')\n};\n\ninternals.applyDefaults = function (schema) {\n  Hoek.assert(this, 'Must be invoked on a Joi instance.');\n\n  if (this._defaults) {\n    schema = this._defaults(schema);\n  }\n\n  schema._currentJoi = this;\n  return schema;\n};\n\ninternals.root = function () {\n  var any = new Any();\n  var root = any.clone();\n  Any.prototype._currentJoi = root;\n  root._currentJoi = root;\n\n  root.any = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.any() does not allow arguments.');\n    return internals.applyDefaults.call(this, any);\n  };\n\n  root.alternatives = root.alt = function () {\n    var alternatives = internals.applyDefaults.call(this, internals.alternatives);\n    return arguments.length ? alternatives.try.apply(alternatives, arguments) : alternatives;\n  };\n\n  root.array = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.array() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.array);\n  };\n\n  root.boolean = root.bool = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.boolean() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.boolean);\n  };\n\n  root.binary = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.binary() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.binary);\n  };\n\n  root.date = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.date() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.date);\n  };\n\n  root.func = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.func() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.func);\n  };\n\n  root.number = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.number() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.number);\n  };\n\n  root.object = function () {\n    var object = internals.applyDefaults.call(this, internals.object);\n    return arguments.length ? object.keys.apply(object, arguments) : object;\n  };\n\n  root.string = function () {\n    Hoek.assert(arguments.length === 0, 'Joi.string() does not allow arguments.');\n    return internals.applyDefaults.call(this, internals.string);\n  };\n\n  root.ref = function () {\n    return Ref.create.apply(null, arguments);\n  };\n\n  root.isRef = function (ref) {\n    return Ref.isRef(ref);\n  };\n\n  root.validate = function (value\n  /*, [schema], [options], callback */\n  ) {\n    var last = arguments[arguments.length - 1];\n    var callback = typeof last === 'function' ? last : null;\n    var count = arguments.length - (callback ? 1 : 0);\n\n    if (count === 1) {\n      return any.validate(value, callback);\n    }\n\n    var options = count === 3 ? arguments[2] : {};\n    var schema = root.compile(arguments[1]);\n    return schema._validateWithOptions(value, options, callback);\n  };\n\n  root.describe = function () {\n    var schema = arguments.length ? root.compile(arguments[0]) : any;\n    return schema.describe();\n  };\n\n  root.compile = function (schema) {\n    try {\n      return Cast.schema(this, schema);\n    } catch (err) {\n      if (err.hasOwnProperty('path')) {\n        err.message = err.message + '(' + err.path + ')';\n      }\n\n      throw err;\n    }\n  };\n\n  root.assert = function (value, schema, message) {\n    root.attempt(value, schema, message);\n  };\n\n  root.attempt = function (value, schema, message) {\n    var result = root.validate(value, schema);\n    var error = result.error;\n\n    if (error) {\n      if (!message) {\n        if (typeof error.annotate === 'function') {\n          error.message = error.annotate();\n        }\n\n        throw error;\n      }\n\n      if (!(message instanceof Error)) {\n        if (typeof error.annotate === 'function') {\n          error.message = \"\".concat(message, \" \").concat(error.annotate());\n        }\n\n        throw error;\n      }\n\n      throw message;\n    }\n\n    return result.value;\n  };\n\n  root.reach = function (schema, path) {\n    Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\n    Hoek.assert(typeof path === 'string', 'path must be a string');\n\n    if (path === '') {\n      return schema;\n    }\n\n    var parts = path.split('.');\n    var children = schema._inner.children;\n\n    if (!children) {\n      return;\n    }\n\n    var key = parts[0];\n\n    for (var i = 0; i < children.length; ++i) {\n      var child = children[i];\n\n      if (child.key === key) {\n        return this.reach(child.schema, path.substr(key.length + 1));\n      }\n    }\n  };\n\n  root.lazy = function (fn) {\n    return Lazy.set(fn);\n  };\n\n  root.defaults = function (fn) {\n    var _this = this;\n\n    Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\n    var joi = Object.create(this.any());\n    joi = fn(joi);\n    Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\n    Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\n\n    joi._defaults = function (schema) {\n      if (_this._defaults) {\n        schema = _this._defaults(schema);\n        Hoek.assert(schema instanceof _this.constructor, 'defaults() must return a schema');\n      }\n\n      schema = fn(schema);\n      Hoek.assert(schema instanceof _this.constructor, 'defaults() must return a schema');\n      return schema;\n    };\n\n    return joi;\n  };\n\n  root.extend = function () {\n    var _this2 = this;\n\n    var extensions = Hoek.flatten(Array.prototype.slice.call(arguments));\n    Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\n    this.assert(extensions, root.extensionsSchema);\n    var joi = Object.create(this.any());\n    Object.assign(joi, this);\n\n    var _loop = function _loop(i) {\n      var extension = extensions[i];\n\n      if (typeof extension === 'function') {\n        extension = extension(joi);\n      }\n\n      _this2.assert(extension, root.extensionSchema);\n\n      var base = (extension.base || _this2.any()).clone(); // Cloning because we're going to override language afterwards\n\n\n      var ctor = base.constructor;\n\n      var type =\n      /*#__PURE__*/\n      function (_ctor) {\n        _inherits(type, _ctor);\n\n        // eslint-disable-line no-loop-func\n        function type() {\n          var _this3;\n\n          _classCallCheck(this, type);\n\n          _this3 = _possibleConstructorReturn(this, _getPrototypeOf(type).call(this));\n\n          if (extension.base) {\n            Object.assign(_assertThisInitialized(_this3), base);\n          }\n\n          _this3._type = extension.name;\n\n          if (extension.language) {\n            _this3._settings = _this3._settings || {\n              language: {}\n            };\n            _this3._settings.language = Hoek.applyToDefaults(_this3._settings.language, _defineProperty({}, extension.name, extension.language));\n          }\n\n          return _this3;\n        }\n\n        return type;\n      }(ctor);\n\n      if (extension.coerce) {\n        type.prototype._coerce = function (value, state, options) {\n          if (ctor.prototype._coerce) {\n            var baseRet = ctor.prototype._coerce.call(this, value, state, options);\n\n            if (baseRet.errors) {\n              return baseRet;\n            }\n\n            value = baseRet.value;\n          }\n\n          var ret = extension.coerce.call(this, value, state, options);\n\n          if (ret instanceof Errors.Err) {\n            return {\n              value: value,\n              errors: ret\n            };\n          }\n\n          return {\n            value: ret\n          };\n        };\n      }\n\n      if (extension.pre) {\n        type.prototype._base = function (value, state, options) {\n          if (ctor.prototype._base) {\n            var baseRet = ctor.prototype._base.call(this, value, state, options);\n\n            if (baseRet.errors) {\n              return baseRet;\n            }\n\n            value = baseRet.value;\n          }\n\n          var ret = extension.pre.call(this, value, state, options);\n\n          if (ret instanceof Errors.Err) {\n            return {\n              value: value,\n              errors: ret\n            };\n          }\n\n          return {\n            value: ret\n          };\n        };\n      }\n\n      if (extension.rules) {\n        var _loop2 = function _loop2(j) {\n          var rule = extension.rules[j];\n          var ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map(function (k) {\n            return k.key;\n          }) : Object.keys(rule.params) : [];\n          var validateArgs = rule.params ? Cast.schema(_this2, rule.params) : null;\n\n          type.prototype[rule.name] = function () {\n            // eslint-disable-line no-loop-func\n            if (arguments.length > ruleArgs.length) {\n              throw new Error('Unexpected number of arguments');\n            }\n\n            var args = Array.prototype.slice.call(arguments);\n            var hasRef = false;\n            var arg = {};\n\n            for (var k = 0; k < ruleArgs.length; ++k) {\n              arg[ruleArgs[k]] = args[k];\n\n              if (!hasRef && Ref.isRef(args[k])) {\n                hasRef = true;\n              }\n            }\n\n            if (validateArgs) {\n              arg = joi.attempt(arg, validateArgs);\n            }\n\n            var schema;\n\n            if (rule.validate) {\n              var validate = function validate(value, state, options) {\n                return rule.validate.call(this, arg, value, state, options);\n              };\n\n              schema = this._test(rule.name, arg, validate, {\n                description: rule.description,\n                hasRef: hasRef\n              });\n            } else {\n              schema = this.clone();\n            }\n\n            if (rule.setup) {\n              var newSchema = rule.setup.call(schema, arg);\n\n              if (newSchema !== undefined) {\n                Hoek.assert(newSchema instanceof Any, \"Setup of extension Joi.\".concat(this._type, \"().\").concat(rule.name, \"() must return undefined or a Joi object\"));\n                schema = newSchema;\n              }\n            }\n\n            return schema;\n          };\n        };\n\n        for (var j = 0; j < extension.rules.length; ++j) {\n          _loop2(j);\n        }\n      }\n\n      if (extension.describe) {\n        type.prototype.describe = function () {\n          var description = ctor.prototype.describe.call(this);\n          return extension.describe.call(this, description);\n        };\n      }\n\n      var instance = new type();\n\n      joi[extension.name] = function () {\n        return internals.applyDefaults.call(this, instance);\n      };\n    };\n\n    for (var i = 0; i < extensions.length; ++i) {\n      _loop(i);\n    }\n\n    return joi;\n  };\n\n  root.extensionSchema = internals.object.keys({\n    base: internals.object.type(Any, 'Joi object'),\n    name: internals.string.required(),\n    coerce: internals.func.arity(3),\n    pre: internals.func.arity(3),\n    language: internals.object,\n    describe: internals.func.arity(1),\n    rules: internals.array.items(internals.object.keys({\n      name: internals.string.required(),\n      setup: internals.func.arity(1),\n      validate: internals.func.arity(4),\n      params: [internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')), internals.object.type(internals.object.constructor, 'Joi object')],\n      description: [internals.string, internals.func.arity(1)]\n    }).or('setup', 'validate'))\n  }).strict();\n  root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();\n  root.version = require('../package.json').version;\n  return root;\n};\n\nmodule.exports = internals.root();","map":null,"metadata":{},"sourceType":"script"}