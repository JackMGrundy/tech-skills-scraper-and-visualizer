{"ast":null,"code":"import { geoProjectionMutator as projectionMutator, geoCircle } from \"d3-geo\";\nimport { abs, acos, asin, atan2, cos, degrees, epsilon, halfPi, radians, sqrt, sin } from \"./math\";\nexport function hammerRetroazimuthalRaw(phi0) {\n  var sinPhi0 = sin(phi0),\n      cosPhi0 = cos(phi0),\n      rotate = hammerRetroazimuthalRotation(phi0);\n  rotate.invert = hammerRetroazimuthalRotation(-phi0);\n\n  function forward(lambda, phi) {\n    var p = rotate(lambda, phi);\n    lambda = p[0], phi = p[1];\n    var sinPhi = sin(phi),\n        cosPhi = cos(phi),\n        cosLambda = cos(lambda),\n        z = acos(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda),\n        sinz = sin(z),\n        K = abs(sinz) > epsilon ? z / sinz : 1;\n    return [K * cosPhi0 * sin(lambda), (abs(lambda) > halfPi ? K : -K) * ( // rotate for back hemisphere\n    sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)];\n  }\n\n  forward.invert = function (x, y) {\n    var rho = sqrt(x * x + y * y),\n        sinz = -sin(rho),\n        cosz = cos(rho),\n        a = rho * cosz,\n        b = -y * sinz,\n        c = rho * sinPhi0,\n        d = sqrt(a * a + b * b - c * c),\n        phi = atan2(a * c + b * d, b * c - a * d),\n        lambda = (rho > halfPi ? -1 : 1) * atan2(x * sinz, rho * cos(phi) * cosz + y * sin(phi) * sinz);\n    return rotate.invert(lambda, phi);\n  };\n\n  return forward;\n} // Latitudinal rotation by phi0.\n// Temporary hack until D3 supports arbitrary small-circle clipping origins.\n\nfunction hammerRetroazimuthalRotation(phi0) {\n  var sinPhi0 = sin(phi0),\n      cosPhi0 = cos(phi0);\n  return function (lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi);\n    return [atan2(y, x * cosPhi0 - z * sinPhi0), asin(z * cosPhi0 + x * sinPhi0)];\n  };\n}\n\nexport default function () {\n  var phi0 = 0,\n      m = projectionMutator(hammerRetroazimuthalRaw),\n      p = m(phi0),\n      rotate_ = p.rotate,\n      stream_ = p.stream,\n      circle = geoCircle();\n\n  p.parallel = function (_) {\n    if (!arguments.length) return phi0 * degrees;\n    var r = p.rotate();\n    return m(phi0 = _ * radians).rotate(r);\n  }; // Temporary hack; see hammerRetroazimuthalRotation.\n\n\n  p.rotate = function (_) {\n    if (!arguments.length) return _ = rotate_.call(p), _[1] += phi0 * degrees, _;\n    rotate_.call(p, [_[0], _[1] - phi0 * degrees]);\n    circle.center([-_[0], -_[1]]);\n    return p;\n  };\n\n  p.stream = function (stream) {\n    stream = stream_(stream);\n\n    stream.sphere = function () {\n      stream.polygonStart();\n      var epsilon = 1e-2,\n          ring = circle.radius(90 - epsilon)().coordinates[0],\n          n = ring.length - 1,\n          i = -1,\n          p;\n      stream.lineStart();\n\n      while (++i < n) {\n        stream.point((p = ring[i])[0], p[1]);\n      }\n\n      stream.lineEnd();\n      ring = circle.radius(90 + epsilon)().coordinates[0];\n      n = ring.length - 1;\n      stream.lineStart();\n\n      while (--i >= 0) {\n        stream.point((p = ring[i])[0], p[1]);\n      }\n\n      stream.lineEnd();\n      stream.polygonEnd();\n    };\n\n    return stream;\n  };\n\n  return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);\n}","map":null,"metadata":{},"sourceType":"module"}